@page "/editflow/{Id:int}"
@using Blazor.Diagrams;
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Components.Widgets;
@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Geometry;
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.Models.Base
@using Blazor.Diagrams.Core.PathGenerators;
@using Blazor.Diagrams.Core.Routers;
@using Blazor.Diagrams.Options;
@using Hasm.Models
@using Hasm.Services
@using Hasm.Services.Automations
@using Hasm.Services.Automations.Flow
@using Hasm.Services.Interfaces
@using System.Reflection
@using System.Linq.Expressions
@inject AutomationService AutomationService
@inject DialogService DialogService
@inject DataService DataService
@inject ContextMenuService ContextMenuService
@inject ClipboardService ClipboardService
@inject NavigationManager Navigation
@inject UIEventRegistration UIEventRegistration
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>HASM - Edit Flow</PageTitle>

<NavigationLock ConfirmExternalNavigation="true"
                OnBeforeInternalNavigation="OnBeforeInternalNavigation" />

@if (Automation != null)
{
    <span>Edit Flow: @Automation.Name (@(FlowHandler?.RunningState.ToString() ?? "-"))</span>
    @if (!string.IsNullOrWhiteSpace(FlowHandler?.ErrorMessage))
    {
        <p>@FlowHandler.ErrorMessage</p>
    }
    <RadzenSplitter Orientation="Radzen.Orientation.Vertical" style="width: 100%;height: 95vh">
        <RadzenSplitterPane Size="75%" Min="300px">
            <div class="diagram-container" style="width: 100%; height: 70vh; border: 1px solid black; position: relative;" @oncontextmenu="OnContextMenu" @oncontextmenu:preventDefault="true">

                <div style="position: absolute; top: 10px; left: 10px; z-index: 10;" @oncontextmenu:preventDefault="false">
                    <RadzenButton Size="ButtonSize.Small" Text="Pre Start Action " Click="EditPreStartActionAsync" />
                </div>

                <div style="position: absolute; top: 10px; right: 10px; z-index: 10;" @oncontextmenu:preventDefault="false">
                    <RadzenUpload Icon="upload" ChooseText="Import" Auto=true Multiple=false Accept="text/json" Change=@(args => OnImport(args)) InputAttributes="@(new Dictionary<string, object>() { { "aria-label", "Import" } })" />
                    <RadzenButton Size="ButtonSize.Small" Text="+" Click="@(() => Diagram.SetZoom(Diagram.Zoom * 1.25))" />
                    <RadzenButton Size="ButtonSize.Small" Text="-" Click="@(() => Diagram.SetZoom(Diagram.Zoom * 0.75))" />
                    <RadzenButton Size="ButtonSize.Small" Text="Reset" Click="@(() => Diagram.SetZoom(1.0))" />
                    <RadzenButton Size="ButtonSize.Small" Text="Fit" Click="@(() => Diagram.ZoomToFit())" />
                </div>

                <CascadingValue Value="Diagram" IsFixed="true">
                    <DiagramCanvas>
                        <Widgets>
                            <SelectionBoxWidget />
                        </Widgets>
                    </DiagramCanvas>
                </CascadingValue>
            </div>
        </RadzenSplitterPane>
        <RadzenSplitterPane Min="100px">
            <RadzenTabs>
                <Tabs>
                    <RadzenTabsItem Text="Variables">
                        <VariablesControl Automation="Automation" AllowColumnPicking=false />
                    </RadzenTabsItem>
                    <RadzenTabsItem Text="Intermediate">
                        <div style="position: relative;">
                            <div style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                                <RadzenButton Size="ButtonSize.Small" Text="Execute" Click="@ExecuteInteractive" Disabled="@(string.IsNullOrWhiteSpace(executeCommand) || FlowHandler?.RunningState != FlowHandler.FlowRunningState.Active)" />
                            </div>
                            <RadzenTextArea @bind-Value=@executeCommand Style=@($"width:100%;") Rows="2" Placeholder="interactive javascript execution" />
                            <div>
                                <pre>@executeCommandResult</pre>
                            </div>
                        </div>
                    </RadzenTabsItem>
                    <RadzenTabsItem Text="Log">
                        <div style="position: relative;">
                            <div style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                                <RadzenButton Size="ButtonSize.Small" Text="Clear" Click="@ClearLog" />
                                <RadzenButton Size="ButtonSize.Small" Text="@(_pauseLog ? "Continue" : "Pause")" Click="@PauseLog" />
                            </div>
                            <div style="width: 100%;height: 150px;border: 1px solid black; overflow: scroll">
                                @foreach (var data in logLines)
                                {
                                    <pre style="margin:0px;padding:0px;">@($"{data.Time.ToString("HH:mm.ss.fff")} {data.Message}")</pre>
                                }
                            </div>
                        </div>
                    </RadzenTabsItem>
                </Tabs>
            </RadzenTabs>
        </RadzenSplitterPane>
    </RadzenSplitter>
}
else
{
    <h2>Edit Flow</h2>
}

@code {
    [Parameter]
    public int Id { get; set; }

    private sealed class NodeUIData
    {
        public int X { get; set; } = 50;
        public int Y { get; set; } = 50;
    }

    private sealed class LogData
    {
        public string Message { get; set; } = string.Empty;
        public DateTime Time { get; set; } = DateTime.Now;
    }

    private List<(string name, string description, Type stepType, Type nodeModel, Type nodeWidget, Type dialog)> stepNodeMappings = [
        ("Variable", "Get variable value", typeof(StepVariableValue), typeof(StepVariableValueNodeModel), typeof(StepVariableValueNodeWidget), typeof(AddOrEditStepVariableValueDialog)),
        ("Logic AND", "All inputs true", typeof(StepAnd), typeof(StepAndNodeModel), typeof(StepAndNodeWidget), typeof(AddOrEditStepAndDialog))
    ];

    private BlazorDiagram Diagram { get; set; } = null!;
    private readonly UndoRedo<string> _undoRedo = new();
    private string? _unsavedData = null;
    private Automation Automation = null!;
    private FlowHandler FlowHandler = null!;
    private readonly List<LogData> logLines = [];
    private string? executeCommand;
    private string? executeCommandResult;
    private bool _pauseLog;
    private bool _draggingElement;
    private FlowHandler.AutomationProperties AutomationProperties = new();

    protected override async Task OnInitializedAsync()
    {
        UIEventRegistration.LogEntryAdded += LogEvent;
        UIEventRegistration.FlowHandlerInfoChanged += FlowHandlerInfoChanged;
        UIEventRegistration.AutomationHandlerChanged += AutomationHandlerChanged;
        UIEventRegistration.AutomationInfoChanged += AutomationInfoChanged;
        FlowHandler = (FlowHandler)AutomationService.GetAutomation(Id);
        var options = new BlazorDiagramOptions
        {
            AllowMultiSelection = true,
            Zoom =
                                                        {
                        Enabled = true
                                                        },
            Links =
                                                        {
                        DefaultRouter = new NormalRouter(),
                        DefaultPathGenerator = new SmoothPathGenerator(),
                        RequireTarget = true,
                        Factory = (diagram, source, targetAnchor) =>
                        {
                            Anchor? source2;
                            if (!(source is NodeModel model3))
                            {
                                if (!(source is PortModel port2))
                                {
                                    throw new NotImplementedException();
                                }

                                source2 = new SinglePortAnchor(port2);
                            }
                            else
                            {
                                source2 = new ShapeIntersectionAnchor(model3);
                            }

                            var linkModel = new LinkModel(source2, targetAnchor);
                            linkModel.TargetMarker = LinkMarker.Arrow;
                            _draggingElement = true;
                            return linkModel;
                        }
                                                        }
        };

        Diagram = new BlazorDiagram(options);
        foreach(var mapping in stepNodeMappings)
        {
            Diagram.RegisterComponent(mapping.nodeModel, mapping.nodeWidget);
        }
        Diagram.RegisterComponent<InformationNodeModel, InformationNodeWidget>();

        var keyboardBehavior = Diagram.GetBehavior<Blazor.Diagrams.Core.Behaviors.KeyboardShortcutsBehavior>();
        keyboardBehavior!.RemoveShortcut("g", ctrl: true, shift: false, alt: true);
        keyboardBehavior.RemoveShortcut("Delete", ctrl: false, shift: false, alt: false);
        keyboardBehavior.SetShortcut("Delete", ctrl: false, shift: false, alt: false, DeleteSelection);
        keyboardBehavior.SetShortcut("a", ctrl: true, shift: false, alt: false, SelectAll);
        keyboardBehavior.SetShortcut("z", ctrl: true, shift: false, alt: false, UndoAsync);
        keyboardBehavior.SetShortcut("y", ctrl: true, shift: false, alt: false, RedoAsync);
        Diagram.PointerDoubleClick += DiagramPointerDoubleClickAsync;
        Diagram.PointerUp += DiagramPointerUpAsync;
        Diagram.PointerMove += DiagramPointerMove;
        Diagram.PointerDown += DiagramPointerDown;

        await ReloadDiagramAsync();
        RefreshInformations();
        await base.OnInitializedAsync();
    }

    void LogEvent(object? sender, LogEntry logEntry)
    {
        if (_pauseLog || logEntry.AutomationId != Automation?.Id) return;

        InvokeAsync(() =>
        {
            logLines.Add(new LogData() { Message = logEntry.Message, Time = logEntry.Timestamp.ToLocalTime() });
            while (logLines.Count > 200)
            {
                logLines.RemoveAt(0);
            }
            StateHasChanged();
        });
    }

    async Task EditPreStartActionAsync()
    {
        SaveAutomationPropertiesToAutomation();
        var result = await DialogService.ShowDialogAsync<Dialogs.ScriptEditorDialog, string?>("Pre Start Action", dialog =>
        {
            dialog.Script = AutomationProperties.PreStartAction;
            dialog.SystemScript = EngineScriptBuilder.BuildEngineScriptForEditor(Automation);
        });
        if (result != null)
        {
            AutomationProperties.PreStartAction = result;
        }
    }

    void SaveAutomationPropertiesToAutomation()
    {
        Automation.Data = System.Text.Json.JsonSerializer.Serialize(AutomationProperties);
    }

    private ValueTask SelectAll(Blazor.Diagrams.Core.Diagram diagram)
    {
        foreach (var node in diagram.Nodes)
        {
            diagram.SelectModel(node, false);
        }
        foreach (var link in diagram.Links)
        {
            diagram.SelectModel(link, false);
        }
        return ValueTask.CompletedTask;
    }

    private ValueTask DeleteSelection(Blazor.Diagrams.Core.Diagram diagram)
    {
        AddUndo();
        var selectedModels = diagram.GetSelectedModels().ToList();
        foreach (var sm in selectedModels)
        {
            LinkModel? link = sm as LinkModel;
            if (link != null)
            {
                RemoveLink(link);
            }
        }
        foreach (var sm in selectedModels)
        {
            NodeModel? node = sm as NodeModel;
            if (node != null)
            {
                RemoveNode(node);
            }
        }
        Diagram.Refresh();
        return ValueTask.CompletedTask;
    }

    void RemoveLink(LinkModel link)
    {
        var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link!.Source).Port.Parent;
        var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
        var sourceStep = source.GetStep(AutomationProperties)!;
        var targetStep = target.GetStep(AutomationProperties)!;
        sourceStep.StepData.NextSteps.Remove(targetStep.StepData.Id);
        Diagram.Links.Remove(link!);
    }

    void RemoveNode(NodeModel node)
    {
        if (node is StepNodeModel smNode)
        {
            var step = smNode.GetStep(AutomationProperties)!;
            AutomationProperties.RemoveStep(step);
            Diagram.Nodes.Remove(node!);
        }
        else if (node is InformationNodeModel infNode)
        {
            var information = infNode.GetInformation(AutomationProperties)!;
            AutomationProperties.Informations.Remove(information);
            Diagram.Nodes.Remove(node!);
        }
    }

    private string? GetUndoData()
    {
        AddUIDataToComponents();
        SaveAutomationPropertiesToAutomation();
        return System.Text.Json.JsonSerializer.Serialize(Automation);
    }

    private void AddUIDataToComponents()
    {
        foreach (var step in AutomationProperties.Steps)
        {
            var uiData = new NodeUIData();
            var node = Diagram.GetNode(step)!;
            uiData.X = (int)node.Position.X;
            uiData.Y = (int)node.Position.Y;
            step.StepData.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
        }
        foreach (var information in AutomationProperties.Informations)
        {
            var uiData = new NodeUIData();
            var node = Diagram.GetNode(information)!;
            uiData.X = (int)node.Position.X;
            uiData.Y = (int)node.Position.Y;
            information.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
        }
    }

    private void FlowHandlerInfoChanged(object? sender, FlowHandler.FlowHandlerInfo flowInfo)
    {
        InvokeAsync(() =>
        {
            if (flowInfo.UpdatedStep != null)
            {
                var node = Diagram.GetNode(flowInfo.UpdatedStep);
                if (node is StepNodeModel stepNode)
                {
                    stepNode.Step.Payload = flowInfo.UpdatedStep.Payload;
                    stepNode.Step.PayloadUpdatedAt = flowInfo.UpdatedStep.PayloadUpdatedAt;
                    stepNode.Refresh();
                }
            }
            StateHasChanged();
    }   );
    }

    private async Task OnBeforeInternalNavigation(LocationChangingContext context)
    {
        if (_unsavedData != GetUndoData())
        {
            var isConfirmed = await JS.InvokeAsync<bool>("confirm", "Changes are not saved. Are you sure you want to leave the page without saving changes?");

            if (!isConfirmed)
            {
                context.PreventNavigation();
            }
        }
    }

    private void AutomationHandlerChanged(object? sender, IAutomationHandler automationHandler)
    {
        InvokeAsync(async () =>
        {
            if (automationHandler.Automation.Id < 0)
            {
                NavigationManager.NavigateTo("\\");
            }
            else
            {
                await ReloadDiagramAsync();
            }
        });
    }

    private void AutomationInfoChanged(object? sender, AutomationInfo stateMachineScheduledInfo)
    {
        if (stateMachineScheduledInfo.AutomationId != Automation.Id)
        {
            return;
        }
        RefreshInformations();
    }

    private void RefreshInformations()
    {
        if (FlowHandler?.RunningState != FlowHandler.FlowRunningState.Active)
        {
            return;
        }


        var allEvaluations = AutomationProperties.Informations.Where(x => !string.IsNullOrWhiteSpace(x.Evaluation)).ToList();
        if (!allEvaluations.Any())
        {
            return;
        }

        FlowHandler.ExecuteScript(allEvaluations);

        foreach (var information in allEvaluations)
        {
            var node = Diagram.GetNode(information);
            if (node is InformationNodeModel infNode)
            {
                infNode.Refresh();
            }
        }
    }

    public void Dispose()
    {
        UIEventRegistration.AutomationInfoChanged -= AutomationInfoChanged;
        UIEventRegistration.AutomationHandlerChanged -= AutomationHandlerChanged;
        UIEventRegistration.LogEntryAdded -= LogEvent;
        UIEventRegistration.FlowHandlerInfoChanged -= FlowHandlerInfoChanged;
        Diagram.PointerUp -= DiagramPointerUpAsync;
        Diagram.PointerDoubleClick -= DiagramPointerDoubleClickAsync;
    }

    private void AddUndo()
    {
        var data = GetUndoData();
        if (data != null)
        {
            _undoRedo.Add(data);
        }
    }

    private async ValueTask UndoAsync(Blazor.Diagrams.Core.Diagram diagram)
    {
        if (CanUndo())
        {
            var data = _undoRedo.Undo();
            if (data != null)
            {
                var automation = System.Text.Json.JsonSerializer.Deserialize<Automation>(data);
                if (automation != null)
                {
                    await OnImport(automation);
                }
            }
        }
    }

    private async ValueTask RedoAsync(Blazor.Diagrams.Core.Diagram diagram)
    {
        if (CanRedo())
        {
            var data = _undoRedo.Redo();
            if (data != null)
            {
                var automation = System.Text.Json.JsonSerializer.Deserialize<Automation>(data);
                if (automation != null)
                {
                    await OnImport(automation);
                }
            }
        }
    }

    private bool CanUndo() => _undoRedo.CanUndo();
    private bool CanRedo() => _undoRedo.CanRedo();

    async void DiagramPointerDoubleClickAsync(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (args.Button != 0) return;

        if (model is InformationNodeModel infnode)
        {
            await EditInformationAsync(infnode);
        }
        else if (model is StepNodeModel node)
        {
            await EditStepAsync(node);
        }
    }

    async Task AddStepAsync(int x, int y)
    {
        SaveAutomationPropertiesToAutomation();
        var stepType = await DialogService.ShowDialogAsync<SelectStepTypeDialog, string>("Select Step Type", dialog =>
        {
            dialog.StepTypes = stepNodeMappings.ToDictionary(x => x.name, x => $"{x.name}: {x.description}" );
        });
        if (string.IsNullOrWhiteSpace(stepType))
        {
            return;
        }
        var info = stepNodeMappings.FirstOrDefault(x => x.name == stepType);
        var step = await ShowStepDialogAsync(info.name, null);
        if (step != null)
        {
            AddNewStep(step, x, y);
            Diagram.Refresh();
        }
    }

    async Task<Step?> ShowStepDialogAsync(string name, Step? step)
    {
        var info = step == null ? stepNodeMappings.FirstOrDefault(x => x.name == name) : stepNodeMappings.FirstOrDefault(x => x.stepType == step.StepData.Type);
        if (info == default)
        {
            return null;
        }

        switch (info.dialog.Name)
        {
            case "AddOrEditStepVariableValueDialog":
                return await DialogService.ShowDialogAsync<AddOrEditStepVariableValueDialog, StepVariableValue>($"Edit Step: {step?.StepData.Name}", dialog =>
                {
                    dialog.Step = step as StepVariableValue;
                    dialog.Automation = Automation;
                });
            case "AddOrEditStepAndDialog":
                return await DialogService.ShowDialogAsync<AddOrEditStepAndDialog, StepAnd>($"Edit Step: {step?.StepData.Name}", dialog =>
                {
                    dialog.Step = step as StepAnd;
                    dialog.Automation = Automation;
                });
        }
        return null;
    }

    async Task EditStepAsync(NodeModel node)
    {
        var info = stepNodeMappings.FirstOrDefault(x => x.nodeModel == node.GetType());
        if (info == default)
        {
            return;
        }
        var step = node.GetStep(AutomationProperties)!;
        var result = await ShowStepDialogAsync(info.name, step);
        if (result != null)
        {
            AddUndo();
            step.StepData.Name = result.StepData.Name;
            step.StepData.Description = result.StepData.Description;
            step.StepData.StepParameters = result.StepData.StepParameters;
            node.Title = step.StepData.Name;
            node.Refresh();
        }
    }

    async Task EditInformationAsync(NodeModel node)
    {
        SaveAutomationPropertiesToAutomation();
        var information = node.GetInformation(AutomationProperties)!;
        var result = await DialogService.ShowDialogAsync<AddOrEditInformationDialog, Information>($"Edit Information", dialog =>
        {
            dialog.Information = information;
            dialog.Automation = Automation;
        });
        if (result != null)
        {
            AddUndo();
            information.Description = result.Description;
            information.Evaluation = result.Evaluation;
            information.EvaluationResult = "";

            node.Title = information.Description ?? information.Evaluation ?? "";
            RefreshInformations();
            node.Refresh();
        }
    }

    Model? modelOnPointerUp = null;
    void OnContextMenu(MouseEventArgs args)
    {
        if (modelOnPointerUp is NodeModel node)
        {
        }
        else if (modelOnPointerUp is LinkModel link)
        {
        }
        else
        {
                       ContextMenuService.Open(args, ds =>
    @<RadzenMenu Click="OnContextMenuItemClick">
    <RadzenMenuItem Text="Edit properties" Value="5"></RadzenMenuItem>
    <RadzenMenuItem Text="Add step" Value="1"></RadzenMenuItem>
    <RadzenMenuItem Text="Add information" Value="20"></RadzenMenuItem>
    <RadzenMenuItem Text="Save" Value="2"></RadzenMenuItem>
    <RadzenMenuItem Text="Copy" Value="8">
        <RadzenMenuItem Text="Selection" Value="9" Disabled="@(!Diagram.GetSelectedModels().Any())"></RadzenMenuItem>
        <RadzenMenuItem Text="All steps" Disabled="@(!AutomationProperties.Steps.Any() && !AutomationProperties.Steps.Any())" Value="10"></RadzenMenuItem>
        <RadzenMenuItem Text="Complete state machine" Value="11"></RadzenMenuItem>
    </RadzenMenuItem>
    <RadzenMenuItem Text="Paste" Value="12" Disabled="@(!ClipboardService.CanPaste())"></RadzenMenuItem>
    <RadzenMenuItem Text="Undo" Value="14" Disabled="@(!CanUndo())"></RadzenMenuItem>
    <RadzenMenuItem Text="Redo" Value="15" Disabled="@(!CanRedo())"></RadzenMenuItem>
    <RadzenMenuItem Text="Select all" Value="13" Disabled="@(!AutomationProperties.Steps.Any())"></RadzenMenuItem>
    <RadzenMenuItem Text="Restart" Value="3"></RadzenMenuItem>
    <RadzenMenuItem Text="Reload" Value="4"></RadzenMenuItem>
    <RadzenMenuItem Text="Script" Value="6"></RadzenMenuItem>
    <RadzenMenuItem Text="Export" Value="7"></RadzenMenuItem>
</RadzenMenu>
    );            
        }
    }

    async void OnContextMenuItemClick(MenuItemEventArgs args)
    {
        switch (args.Value)
        {
            case 1:
                {
                    AddUndo();
                    var p = Diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
                    await AddStepAsync((int)p.X, (int)p.Y);
                }
                break;
                case 2:
                    await SaveAsync();
                    break;
                case 3:
                    Restart();
                    break;
                case 4:
                    AddUndo();
                    await ReloadDiagramAsync();
                    break;
            case 5:
                await EditFlowAsync();
                break;
            case 6:
                await ShowFlowAsync();
                break;
            //     case 7:
            //         await ExportAsync();
            //         break;
            //     case 8:
            //         return;
            //     case 9:
            //         CopySelectionToClipboard();
            //         break;
            //     case 10:
            //         CopyAllStepsToClipboard();
            //         break;
            //     case 11:
            //         CopyFlowToClipboard();
            //         break;
            //     case 12:
            //         PasteFromClipboard(args);
            //         break;
            //     case 13:
            //         await SelectAll(Diagram);
            //         break;
                case 14:
                    await UndoAsync(Diagram);
                    break;
                case 15:
                    await RedoAsync(Diagram);
                    break;
            case 20:
                {
                    AddUndo();
                    var p = Diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
                    await AddInformationAsync((int)p.X, (int)p.Y);
                }
                break;
        }
        ContextMenuService.Close();
    }

    void Restart()
    {
        FlowHandler.Restart();
    }

    async Task SaveAsync()
    {
        var removedSteps = AutomationProperties.Steps.Where(x => Diagram.GetNode(x) == null).ToList();
        foreach (var step in removedSteps)
        {
            AutomationProperties.Steps.Remove(step);
        }
        var removedInformations = AutomationProperties.Informations.Where(x => Diagram.GetNode(x) == null).ToList();
        foreach (var information in removedInformations)
        {
            AutomationProperties.Informations.Remove(information);
        }
        AddUIDataToComponents();
        _unsavedData = GetUndoData();
        await DataService.AddOrUpdateAutomationAsync(Automation);
    }

    async Task ShowFlowAsync()
    {
        SaveAutomationPropertiesToAutomation();
        var copy = Automation.CopyObject()!;
        var cpyProperties = AutomationProperties.CopyObject();
        copy.Data = System.Text.Json.JsonSerializer.Serialize(cpyProperties);
        await DialogService.ShowDialogAsync<Dialogs.ScriptEditorDialog, string?>("Flow Script", dialog =>
         {
             dialog.Script = EngineScriptBuilder.BuildEngineScriptForEditor(copy!);
             dialog.ReadOnly = true;
         });
    }

    async Task EditFlowAsync()
    {
        SaveAutomationPropertiesToAutomation();
        var result = await DialogService.ShowDialogAsync<Pages.AddOrEditAutomationDialog, Automation>("Edit Automation", dialog =>
        {
            dialog.Automation = Automation;
        });
        if (result != null)
        {
            AddUndo();
            Automation.Enabled = result.Enabled;
            Automation.Name = result.Name;
            Automation.IsSubAutomation = result.IsSubAutomation;
            Automation.Data = result.Data;
            AutomationProperties = System.Text.Json.JsonSerializer.Deserialize<FlowHandler.AutomationProperties>(result.Data) ?? new FlowHandler.AutomationProperties();
        }
    }

    async Task AddInformationAsync(int x, int y)
    {
        SaveAutomationPropertiesToAutomation();
        var information = await DialogService.ShowDialogAsync<Flow.AddOrEditInformationDialog, Services.Automations.Flow.Information>("Add Information", dialog =>
        {
            dialog.Automation = Automation;
        });
        if (information != null)
        {
            AddNewInformation(information, x, y);
            RefreshInformations();
            Diagram.Refresh();
        }
    }

    Information AddNewInformation(Services.Automations.Flow.Information information, int x, int y)
    {
        information.Id = Guid.NewGuid();
        AutomationProperties.Informations.Add(information);

        var node = Diagram.Nodes.Add(new InformationNodeModel(information, Automation, position: new Blazor.Diagrams.Core.Geometry.Point(x, y))
        {
            Title = information.Description ?? information.Evaluation ?? ""
        });

        return information;
    }

    void DiagramPointerUpAsync(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        _draggingElement = false;
        modelOnPointerUp = null;
        if (args.Button == 0)
        {
            //check if link is added
            var transitionEdited = false;
            foreach (var link in Diagram.Links.ToList())
            {
                if (link.Target.Model == null)
                {
                    Diagram.Links.Remove(link);
                    continue;
                }
                var sourcePort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Alignment;
                var targetPort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Alignment;

                if (sourcePort == PortAlignment.Left)
                {
                    //source is input port, remove link
                    Diagram.Links.Remove(link);
                    continue;                
                }

                if (targetPort == PortAlignment.Right)
                {
                    //target is output port, remove link
                    Diagram.Links.Remove(link);
                    continue;                
                }

                var source3 = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;

                if (source3 == target)
                {
                    Diagram.Links.Remove(link);
                    continue; 
                }

                var sourceStep = source3.GetStep(AutomationProperties)!;
                var targetStep = target.GetStep(AutomationProperties)!;
                var transitionExists = sourceStep.StepData.NextSteps.Contains(targetStep.StepData.Id);
                if (!transitionExists)
                {
                    sourceStep.StepData.NextSteps.Add(targetStep.StepData.Id);
                    transitionEdited = true;
                }
            }

            if (!transitionEdited)
            {
                //maybe two to the same state? not allowed
                HashSet<string> existingTransitions = [];
                foreach (var link in Diagram.Links.ToList())
                {
                    var source3 = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                    var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                    var sourceStep = source3.GetStep(AutomationProperties)!;
                    var targetStep = target.GetStep(AutomationProperties)!;
                    var transitionExists = sourceStep.StepData.NextSteps.Contains(targetStep.StepData.Id);
                    if (transitionExists)
                    {
                        var key = $"{sourceStep.StepData.Id}.{targetStep.StepData.Id}";
                        if (existingTransitions.Contains(key))
                        {
                            Diagram.Links.Remove(link);
                        }
                        else
                        {
                            existingTransitions.Add(key);
                        }
                    }
                }
            }
        }
        else if (args.Button == 2)
        {
            modelOnPointerUp = model;
        }
    }

    async Task OnImport(UploadChangeEventArgs args)
    {
        AddUndo();
        if (!args.Files.Any())
        {
            return;
        }
        var file = args.Files.First();
        var stream = file.OpenReadStream();
        var flow = await System.Text.Json.JsonSerializer.DeserializeAsync<Automation>(stream);
        if (flow != null)
        {
            await OnImport(flow);
        }
    }

    async Task OnImport(Automation automation)
    {
        if (!string.IsNullOrWhiteSpace(automation.Data))
        {
            AutomationProperties = System.Text.Json.JsonSerializer.Deserialize<FlowHandler.AutomationProperties>(automation.Data) ?? new FlowHandler.AutomationProperties();
        }
        else
        {
            AutomationProperties = new();
        }
        SaveAutomationPropertiesToAutomation();
        await ReloadDiagramAsync(Automation);
    }

    async Task ReloadDiagramAsync()
    {
        await ReloadDiagramAsync(null);
        _unsavedData = GetUndoData();
    }

    Step AddNewStep(Step step, int x, int y)
    {
        step.StepData.Id = Guid.NewGuid();
        AutomationProperties.AddStep(step);

        var stepInfo = stepNodeMappings.FirstOrDefault(x => x.stepType == step.StepData.Type);
        var stepNodeModel = (StepNodeModel)Activator.CreateInstance(stepInfo.nodeModel, step, Automation, new Blazor.Diagrams.Core.Geometry.Point(x, y))!;
        stepNodeModel.Title = step.Title;
        var node = Diagram.Nodes.Add(stepNodeModel);

        if (step.StepData.HasInput)
        {
            node.AddPort(PortAlignment.Left);
        }
        node.AddPort(PortAlignment.Right);
        return step;
    }

    Task ReloadDiagramAsync(Automation? useAutomation)
    {
        Diagram.Links.Clear();
        Diagram.Nodes.Clear();
        Automation = useAutomation ?? FlowHandler.Automation;
        if (!string.IsNullOrWhiteSpace(Automation.Data))
        {
            AutomationProperties = System.Text.Json.JsonSerializer.Deserialize<FlowHandler.AutomationProperties>(Automation.Data) ?? new();
        }
        else
        {
            AutomationProperties = new();
        }
        AutomationProperties.CreateStepsFromStepDatas();

        foreach (var step in AutomationProperties.Steps)
        {
            var flowStateHandlerSteps = FlowHandler.GetSteps().ToDictionary(x => x.StepData.Id, x => x);
            if (flowStateHandlerSteps.TryGetValue(step.StepData.Id, out var flowStep))
            {
                step.PayloadUpdatedAt = flowStep.PayloadUpdatedAt;
                step.Payload = flowStep.Payload;
            }
            var stepInfo = stepNodeMappings.FirstOrDefault(x => x.stepType == step.StepData.Type);
            if (stepInfo == default)
            {
                continue;
            }

            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(step.StepData.UIData!);
            var stepNodeModel = (StepNodeModel)Activator.CreateInstance(stepInfo.nodeModel, step, Automation, new Blazor.Diagrams.Core.Geometry.Point(uiData!.X, uiData.Y))!;
            stepNodeModel.Title = step.Title;
            var node = Diagram.Nodes.Add(stepNodeModel);

            if (step.StepData.HasInput)
            {
                node.AddPort(PortAlignment.Left);
            }
            node.AddPort(PortAlignment.Right);
        }
        foreach (var step in AutomationProperties.Steps)
        {
            foreach(var nextStepId in step.StepData.NextSteps)
            {
                var targetStep = AutomationProperties.Steps.FirstOrDefault(x => x.StepData.Id == nextStepId);
                if (targetStep != null)
                {
                    AddLink(step, targetStep);
                }
            }
        }
        foreach (var information in AutomationProperties.Informations)
        {
            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(information.UIData!);
            var node = Diagram.Nodes.Add(new InformationNodeModel(information, Automation, position: new Blazor.Diagrams.Core.Geometry.Point(uiData!.X, uiData.Y))
            {
                Title = information.Description ?? information.Evaluation ?? ""
            });
        }
        StateChanged(null, null);
        RefreshInformations();
        Diagram.Refresh();
        return Task.CompletedTask;
    }

    void StateChanged(object? sender, Step? step)
    {
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    private void AddLink(Step sourceStep, Step targetStep)
    {
        var source = Diagram.GetNode(sourceStep);
        var target = Diagram.GetNode(targetStep);
        var link = Diagram.Links.Add(new LinkModel(source!.Ports.First(x => x.Alignment == PortAlignment.Right), target!.Ports.First(x => x.Alignment == PortAlignment.Left)));
        link.TargetMarker = LinkMarker.Arrow;
    }

    void DiagramPointerMove(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (_draggingElement)
        {
            var relMouse = Diagram.GetRelativePoint(args.ClientX, args.ClientY); //pointer position on canvas element (top left = 0,0)
            var currentPan = Diagram.Pan;
            var moveX = 0;
            var moveY = 0;
            var stepSize = 20;
            var margin = 20;
            if (relMouse.X < margin)
            {
                moveX = stepSize;
            }
            else if (relMouse.X > Diagram.Container!.Width - margin)
            {
                moveX = -stepSize;
            }
            if (relMouse.Y < margin)
            {
                moveY = stepSize;
            }
            else if (relMouse.Y > Diagram.Container!.Height - margin)
            {
                moveY = -stepSize;
            }

            if (moveX != 0 || moveY != 0)
            {
                Diagram.SetPan(currentPan.X + moveX, currentPan.Y + moveY);
            }
        }
    }

    void DiagramPointerDown(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (args.Button == 0)
        {
            AddUndo();
        }
    }

    void ClearLog()
    {
        InvokeAsync(() =>
    {
        logLines.Clear();
        StateHasChanged();
    });
    }

    void PauseLog()
    {
        _pauseLog = !_pauseLog;
    }

    void ExecuteInteractive()
    {
        if (!string.IsNullOrWhiteSpace(executeCommand))
        {
            executeCommandResult = null;
            if (FlowHandler?.RunningState == FlowHandler.FlowRunningState.Active)
            {
                executeCommandResult = FlowHandler.ExecuteScript(executeCommand);
            }
            else
            {
                executeCommandResult = "error: flow not active";
            }
            InvokeAsync(StateHasChanged);
        }
    }
}
