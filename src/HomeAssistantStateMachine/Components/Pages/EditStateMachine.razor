@page "/editstatemachine/{Id:int}"
@inject StateMachineService StateMachineService
@inject DialogService DialogService
@inject ContextMenuService ContextMenuService
@inject IJSRuntime JS
@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.Models.Base
@using HomeAssistantStateMachine.Models
@using HomeAssistantStateMachine.Services
@using Blazor.Diagrams;
@using Blazor.Diagrams.Core.PathGenerators;
@using Blazor.Diagrams.Core.Routers;
@using Blazor.Diagrams.Options;
@using Blazor.Diagrams.Core.Geometry;
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Components.Widgets;
@implements IDisposable

<PageTitle>HASM - Edit State Machine</PageTitle>

@if (StateMachine != null)
{
    <h1>Edit State Machine: @StateMachine.Name (@(StateMachineHandler?.RunningState.ToString() ?? "-"): @(StateMachineHandler?.CurrentState?.Name ?? "-"))</h1>
    @if (!string.IsNullOrWhiteSpace(StateMachineHandler?.ErrorMessage))
    {
        <p>@StateMachineHandler.ErrorMessage</p>
    }
    <RadzenButton Size="ButtonSize.Small" Text="Add State" Click="@(() => AddStateAsync(50, 50))" />
    <RadzenButton Size="ButtonSize.Small" Text="Save" Click="@SaveAsync" />
    <RadzenButton Size="ButtonSize.Small" Text="Stop" Click="@Stop" />
    <RadzenButton Size="ButtonSize.Small" Text="Restart" Click="@Restart" />
    <RadzenButton Size="ButtonSize.Small" Text="Reload" Click="@ReloadDiagramAsync" />
    <RadzenButton Size="ButtonSize.Small" Text="Edit Properties" Click="@EditStateMachineAsync" />
    <RadzenButton Size="ButtonSize.Small" Text="Script" Click="@ShowStateMachineAsync" />
    <RadzenButton Size="ButtonSize.Small" Text="Export" Click="@ExportAsync" />
    <RadzenUpload Icon="upload" ChooseText="Import" Auto=true Multiple=false Accept="text/json" Change=@(args => OnImport(args)) InputAttributes="@(new Dictionary<string,object>(){ { "aria-label", "Import" }})" />

    <div class="diagram-container" style="width: 100%;height: 800px;border: 1px solid black;" @oncontextmenu="OnContextMenuAsync" @oncontextmenu:preventDefault="true">
        <CascadingValue Value="Diagram" IsFixed="true">
            <DiagramCanvas>
                <Widgets>
                    <SelectionBoxWidget />
                </Widgets>
            </DiagramCanvas>
        </CascadingValue>
    </div>
}
else
{
    <h1>Edit State Machine</h1>
}

@code {
    [Parameter]
    public int Id { get; set; }

    private sealed class NodeUIData
    {
        public int X { get; set; } = 50;
        public int Y { get; set; } = 50;
    }

    private sealed class LinkUIData
    {
        public PortAlignment SourcePort { get; set; } = PortAlignment.Bottom;
        public PortAlignment TargetPort { get; set; } = PortAlignment.Top;
    }

    private BlazorDiagram Diagram { get; set; } = null!;
    private StateMachine StateMachine = null!;
    private StateMachineHandler StateMachineHandler = null!;
    private int newIdForAdd = -1;

    protected override async Task OnInitializedAsync()
    {
        StateMachineHandler = StateMachineService.GetStateMachine(Id);
        var options = new BlazorDiagramOptions
                {
                    AllowMultiSelection = true,
                    Zoom =
                        {
                    Enabled = true,
                        },
                    Links =
                        {
                    DefaultRouter = new NormalRouter(),
                    DefaultPathGenerator = new SmoothPathGenerator(),
                    RequireTarget = false,
                    Factory = (diagram, source, targetAnchor) =>
                    {
                        Anchor? source2;
                        if (!(source is NodeModel model3))
                        {
                            if (!(source is PortModel port2))
                            {
                                throw new NotImplementedException();
                            }

                            source2 = new SinglePortAnchor(port2);
                        }
                        else
                        {
                            source2 = new ShapeIntersectionAnchor(model3);
                        }

                        var linkModel = new LinkModel(source2, targetAnchor);
                        linkModel.TargetMarker = LinkMarker.Arrow;
                        //linkModel.Segmentable = true;
                        linkModel.AddLabel("true");

                        return linkModel;
                    }
                        },
                };

        Diagram = new BlazorDiagram(options);
        Diagram.PointerDoubleClick += DiagramPointerDoubleClickAsync;
        Diagram.PointerUp += DiagramPointerUpAsync;
        StateMachineHandler.StateChanged += StateChanged;

        await ReloadDiagramAsync();

        await base.OnInitializedAsync();
    }

    void StateChanged(object? sender, State? state)
    {
        InvokeAsync(() =>
        {
            var currentState = StateMachineHandler.CurrentState;
            StateHasChanged();
        });
    }

    async Task ReloadDiagramAsync()
    {
        await ReloadDiagramAsync(null);
    }

    async Task ReloadDiagramAsync(StateMachine? useStateMachine)
    {
        Diagram.Links.Clear();
        Diagram.Nodes.Clear();
        StateMachine = useStateMachine ?? await StateMachineService.GetStateMachineDataAsync(Id);
        foreach (var state in StateMachine.States)
        {
            state.StateMachine = null;
            var uiData = System.Text.Json.JsonSerializer.Deserialize<NodeUIData>(state.UIData!);
            var node = Diagram.Nodes.Add(new NodeModel(position: new Blazor.Diagrams.Core.Geometry.Point(uiData!.X, uiData.Y))
                    {
                        Title = state.Name
                    });

            node.AddPort(PortAlignment.Bottom);
            node.AddPort(PortAlignment.Top);
            node.AddPort(PortAlignment.Left);
            node.AddPort(PortAlignment.Right);
        }
        foreach (var transition in StateMachine.Transitions)
        {
            var uiData = System.Text.Json.JsonSerializer.Deserialize<LinkUIData>(transition.UIData!);
            transition.FromState = null;
            transition.ToState = null;
            transition.StateMachine = null;
            AddLink(transition, uiData!.SourcePort, uiData!.TargetPort);
        }
        StateChanged(null, null);
        Diagram.Refresh();
    }

    private void AddLink(Transition transition, PortAlignment sourcePortAllignment, PortAlignment targetPortAllignment)
    {
        var source = Diagram.Nodes.First(x => x.Title == StateMachine.States.First(y => y.Id == transition.FromStateId)!.Name);
        var target = Diagram.Nodes.First(x => x.Title == StateMachine.States.First(y => y.Id == transition.ToStateId)!.Name);
        var link = Diagram.Links.Add(new LinkModel(source.Ports.First(x => x.Alignment == sourcePortAllignment), target.Ports.First(x => x.Alignment == targetPortAllignment)));
        link.TargetMarker = LinkMarker.Arrow;
        //link.Segmentable = true;
        link.AddLabel(transition.Description ?? transition.Condition ?? "true");
    }

    public void Dispose()
    {
        StateMachineHandler.StateChanged -= StateChanged;
        Diagram.PointerUp -= DiagramPointerUpAsync;
        Diagram.PointerDoubleClick -= DiagramPointerDoubleClickAsync;
    }

    async Task AddStateAsync(int x, int y)
    {
        var state = await DialogService.ShowDialogAsync<Dialogs.AddOrEditStateDialog, State>("Add State", dialog =>
    {
        dialog.ExistingStateNames = StateMachine.States.Select(x => x.Name).Distinct().ToHashSet();
    });
        if (state != null)
        {
            newIdForAdd--;
            state.Id = newIdForAdd;
            StateMachine.States.Add(state);

            var node = Diagram.Nodes.Add(new NodeModel(position: new Blazor.Diagrams.Core.Geometry.Point(x, y))
                    {
                        Title = state.Name
                    });

            node.AddPort(PortAlignment.Bottom);
            node.AddPort(PortAlignment.Top);
            node.AddPort(PortAlignment.Left);
            node.AddPort(PortAlignment.Right);
            Diagram.Refresh();
        }
    }

    Model? modelOnPointerUp = null;
    async Task OnContextMenuAsync(MouseEventArgs args)
    {
        if (modelOnPointerUp is NodeModel node)
        {
            ContextMenuService.Open(args, ds =>
    @<RadzenMenu Click="OnNodeContextMenuItemClick">
        <RadzenMenuItem Text="Edit" Value="1"></RadzenMenuItem>
        <RadzenMenuItem Text="Delete" Value="2"></RadzenMenuItem>
    </RadzenMenu>);
        }
        else if (modelOnPointerUp is LinkModel link)
        {
            var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
            var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
            var sourceState = StateMachine.States.First(x => x.Name == source.Title);
            var targetState = StateMachine.States.First(x => x.Name == target.Title);

            ContextMenuService.Open(args, ds =>
    @<RadzenMenu Click="OnLinkContextMenuItemClick">
        <RadzenMenuItem Text="Edit" Value="1"></RadzenMenuItem>
        <RadzenMenuItem Text="Delete" Value="4"></RadzenMenuItem>
        <RadzenMenuItem Text="Move Start To" Value="3">
            @foreach (var state in StateMachine.States.Where(x => x.Id != targetState.Id).ToList())
        {
            <RadzenMenuItem Text="@(state.Name)" Value="21">
                <RadzenMenuItem Text="@(PortAlignment.Top.ToString())" Value="@((int)(30 + PortAlignment.Top))"></RadzenMenuItem>
                <RadzenMenuItem Text="@(PortAlignment.Left.ToString())" Value="@((int)(30 + PortAlignment.Left))"></RadzenMenuItem>
                <RadzenMenuItem Text="@(PortAlignment.Bottom.ToString())" Value="@((int)(30 + PortAlignment.Bottom))"></RadzenMenuItem>
                <RadzenMenuItem Text="@(PortAlignment.Right.ToString())" Value="@((int)(30 + PortAlignment.Right))"></RadzenMenuItem>
            </RadzenMenuItem>
        }
        </RadzenMenuItem>
        <RadzenMenuItem Text="Move End To" Value="2">
            @foreach (var state in StateMachine.States.Where(x => x.Id != sourceState.Id).ToList())
        {
            <RadzenMenuItem Text="@(state.Name)" Value="21">
                <RadzenMenuItem Text="@(PortAlignment.Top.ToString())" Value="@((int)(30 + PortAlignment.Top))"></RadzenMenuItem>
                <RadzenMenuItem Text="@(PortAlignment.Left.ToString())" Value="@((int)(30 + PortAlignment.Left))"></RadzenMenuItem>
                <RadzenMenuItem Text="@(PortAlignment.Bottom.ToString())" Value="@((int)(30 + PortAlignment.Bottom))"></RadzenMenuItem>
                <RadzenMenuItem Text="@(PortAlignment.Right.ToString())" Value="@((int)(30 + PortAlignment.Right))"></RadzenMenuItem>
            </RadzenMenuItem>
        }
        </RadzenMenuItem>
    </RadzenMenu>
        );
        }
        else
        {
            ContextMenuService.Open(args, ds =>
    @<RadzenMenu Click="OnContextMenuItemClick">
        <RadzenMenuItem Text="Add state" Value="1"></RadzenMenuItem>
        <RadzenMenuItem Text="Save" Value="2"></RadzenMenuItem>
        <RadzenMenuItem Text="Restart" Value="3"></RadzenMenuItem>
        <RadzenMenuItem Text="Reload" Value="4"></RadzenMenuItem>
        <RadzenMenuItem Text="Edit properties" Value="5"></RadzenMenuItem>
        <RadzenMenuItem Text="Script" Value="6"></RadzenMenuItem>
        <RadzenMenuItem Text="Export" Value="7"></RadzenMenuItem>
    </RadzenMenu>
    );
        }
    }

    async void OnContextMenuItemClick(MenuItemEventArgs args)
    {
        switch (args.Value)
        {
            case 1:
                var p = Diagram.GetRelativeMousePoint((int)args.ClientX, (int)args.ClientY);
                await AddStateAsync((int)p.X, (int)p.Y);
                break;
            case 2:
                await SaveAsync();
                break;
            case 3:
                Restart();
                break;
            case 4:
                await ReloadDiagramAsync();
                break;
            case 5:
                await EditStateMachineAsync();
                break;
            case 6:
                await ShowStateMachineAsync();
                break;
            case 7:
                await ExportAsync();
                break;
        }
        ContextMenuService.Close();
    }

    State? moveToState = null;
    bool changeTarget = false;
    async void OnLinkContextMenuItemClick(MenuItemEventArgs args)
    {
        var link = modelOnPointerUp as LinkModel;
        switch (args.Value)
        {
            case 1:
                ContextMenuService.Close();
                await EditTransitionAsync(link!);
                break;
            case 2:
                moveToState = null;
                changeTarget = true;
                break;
            case 3:
                moveToState = null;
                changeTarget = false;
                break;
            case 21:
                moveToState = StateMachine.States.First(x => x.Name == args.Text);
                break;
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
                //move end of link to top of selected state
                {
                    //current situation
                    var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link!.Source).Port.Parent;
                    var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                    var sourceState = StateMachine.States.First(x => x.Name == source.Title);
                    var targetState = StateMachine.States.First(x => x.Name == target.Title);
                    var transition = StateMachine.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                    var sourcePort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Alignment;
                    var targetPort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Alignment;

                    var newPortAllignment = (PortAlignment)((int)args.Value - 30);

                    if (changeTarget)
                    {
                        transition.ToStateId = moveToState!.Id;
                        AddLink(transition, sourcePort, newPortAllignment);
                    }
                    else
                    {
                        transition.FromStateId = moveToState!.Id;
                        AddLink(transition, newPortAllignment, targetPort);
                    }

                    ContextMenuService.Close();
                    Diagram.Links.Remove(link!);
                    Diagram.Refresh();
                }
                break;
            case 4:
                ContextMenuService.Close();
                Diagram.Links.Remove(link!);
                break;
        }
    }

    async void OnNodeContextMenuItemClick(MenuItemEventArgs args)
    {
        ContextMenuService.Close();
        var node = modelOnPointerUp as NodeModel;
        switch (args.Value)
        {
            case 1:
                await EditStateAsync(node!);
                break;
            case 2:
                Diagram.Nodes.Remove(node!);
                break;
        }
    }

    async void DiagramPointerUpAsync(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        modelOnPointerUp = null;
        if (args.Button == 0)
        {
            //check if link is added
            foreach (var link in Diagram.Links)
            {
                var source3 = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
                var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
                var sourceState = StateMachine.States.First(x => x.Name == source3.Title);
                var targetState = StateMachine.States.First(x => x.Name == target.Title);
                var transition = StateMachine.Transitions.FirstOrDefault(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
                if (transition == null)
                {
                    transition = new()
                        {
                            FromStateId = sourceState.Id,
                            ToStateId = targetState.Id
                        };
                    StateMachine.Transitions.Add(transition);
                    await EditTransitionAsync(link);
                }
            }
        }
        else if (args.Button == 2)
        {
            modelOnPointerUp = model;
        }
    }

    async Task EditTransitionAsync(BaseLinkModel link)
    {
        var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
        var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
        var sourceState = StateMachine.States.First(x => x.Name == source.Title);
        var targetState = StateMachine.States.First(x => x.Name == target.Title);
        var transition = StateMachine.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
        var result = await DialogService.ShowDialogAsync<Dialogs.EditTransitionDialog, Transition>($"Edit Transition: {sourceState.Name} to {targetState.Name}", dialog =>
        {
            dialog.Transition = transition;
        });
        if (result != null)
        {
            transition.Condition = result.Condition;
            transition.Description = result.Description;

            link.Labels.Clear();
            link.AddLabel(transition.Description ?? result.Condition ?? "true");
            link.Refresh();
        }
    }

    async Task EditStateAsync(NodeModel node)
    {
        var state = StateMachine.States.First(x => x.Name == node.Title);
        var result = await DialogService.ShowDialogAsync<Dialogs.AddOrEditStateDialog, State>($"Edit State: {state.Name}", dialog =>
        {
            dialog.State = state;
            dialog.ExistingStateNames = StateMachine.States.Where(x => x.Id != state.Id).Select(x => x.Name).Distinct().ToHashSet();
        });
        if (result != null)
        {
            state.Name = result.Name;
            state.Description = result.Description;
            state.EntryAction = result.EntryAction;
            state.IsErrorState = result.IsErrorState;
            state.IsStartState = result.IsStartState;

            node.Title = state.Name;
            node.Refresh();
        }
    }

    async void DiagramPointerDoubleClickAsync(Model? model, Blazor.Diagrams.Core.Events.PointerEventArgs args)
    {
        if (model is NodeModel node)
        {
            await EditStateAsync(node);
        }
        else if (model is LinkModel link)
        {
            await EditTransitionAsync(link);
        }
    }

    void Restart()
    {
        StateMachineService.RestartMachineState(StateMachine.Id);
    }

    void Stop()
    {
        StateMachineHandler.Stop();
    }

    async Task EditStateMachineAsync()
    {
        var result = await DialogService.ShowDialogAsync<Dialogs.AddOrEditStateMachineDialog, StateMachine>("Edit State Machine", dialog =>
        {
            dialog.StateMachine = StateMachine;
        });
        if (result != null)
        {
            StateMachine.Enabled = result.Enabled;
            StateMachine.Name = result.Name;
            StateMachine.PreScheduleAction = result.PreScheduleAction;
            StateMachine.PreStartAction = result.PreStartAction;
            await StateMachineService.UpdateMachineStatePropertiesAsync(StateMachine);
            await ReloadDiagramAsync();
        }
    }

    async Task ShowStateMachineAsync()
    {
        var copy = StateMachine.CopyObject();
        var removedStates = copy!.States.Where(x => !Diagram.Nodes.Any(y => y.Title == x.Name)).ToList();
        foreach (var state in removedStates)
        {
            copy.States.Remove(state);
        }
        await DialogService.ShowDialogAsync<Dialogs.ShowScriptDialog>("State Machine Script", dialog =>
         {
             dialog.Script = StateMachineHandler.BuildEngineScript(copy);
         });
    }

    private void AddUIDataToStatesAndTransitions()
    {
        foreach (var state in StateMachine.States)
        {
            var uiData = new NodeUIData();
            var node = Diagram.Nodes.First(x => x.Title == state.Name);
            uiData.X = (int)node.Position.X;
            uiData.Y = (int)node.Position.Y;
            state.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
        }
        foreach (var link in Diagram.Links)
        {
            var source = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Parent;
            var target = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Parent;
            var sourceState = StateMachine.States.First(x => x.Name == source.Title);
            var targetState = StateMachine.States.First(x => x.Name == target.Title);
            var transition = StateMachine.Transitions.First(x => x.FromStateId == sourceState.Id && x.ToStateId == targetState.Id);
            var uiData = new LinkUIData();
            uiData.SourcePort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Source).Port.Alignment;
            uiData.TargetPort = ((Blazor.Diagrams.Core.Anchors.SinglePortAnchor)link.Target).Port.Alignment;
            transition.UIData = System.Text.Json.JsonSerializer.Serialize(uiData);
        }
    }


    async Task SaveAsync()
    {
        var removedStates = StateMachine.States.Where(x => !Diagram.Nodes.Any(y => y.Title == x.Name)).ToList();
        foreach (var state in removedStates)
        {
            StateMachine.States.Remove(state);
        }
        AddUIDataToStatesAndTransitions();
        await StateMachineService.UpdateMachineStateAsync(StateMachine);
        await ReloadDiagramAsync();
    }

    private Stream GetFileStream()
    {
        var fileStream = new MemoryStream();

        AddUIDataToStatesAndTransitions();
        System.Text.Json.JsonSerializer.Serialize(fileStream, StateMachine);
        fileStream.Position = 0;

        return fileStream;
    }

    async Task ExportAsync()
    {
        var fileStream = GetFileStream();
        var fileName = "hasm_export.json";

        using var streamRef = new DotNetStreamReference(stream: fileStream);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }

    async Task OnImport(UploadChangeEventArgs args)
    {
        var file = args.Files.First();
        var stream = file.OpenReadStream();
        var stateMachine = await System.Text.Json.JsonSerializer.DeserializeAsync<StateMachine>(stream);
        StateMachine.States.Clear();
        StateMachine.Transitions.Clear();
        foreach (var state in stateMachine!.States)
        {
            StateMachine.States.Add(state);
        }
        foreach (var transition in stateMachine!.Transitions)
        {
            StateMachine.Transitions.Add(transition);
        }
        StateMachine.PreScheduleAction = stateMachine.PreScheduleAction;
        StateMachine.PreStartAction = stateMachine.PreStartAction;
        await ReloadDiagramAsync(StateMachine);
    }
}
